{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"mouse","usesPingPong":true,"mouseMomentum":0,"texture":false,"parentLayer":"78bb30ea-7db6-402b-99c8-a6f7228feceb","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 pixelate(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; float scale = 0.5000 / 2.0; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - 0.5, (scale + 0.01) / 12.0); return vec2( uv.x - modulate.x / aspectRatio + (0.08333 * scale) / 2.0, uv.y - modulate.y + (0.08333 * scale) / 2.0 ); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 pixelTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; uv -= distorted; color = texture(uTexture, uv); color.rgb = chromatic_aberration(color.rgb, uv, distorted * 0.8500 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength, float aspectRatio) { vec4 color = vec4(0);return pixelTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv; float aspectRatio = uResolution.x / uResolution.y;pingpongUv = pixelate(pingpongUv);vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.1900 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, abs(strength), aspectRatio);fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 aspectVec = vec2(aspectRatio, 1.0); vec2 uv = vTextureCoord; vec2 correctedUv = uv * aspectVec;vec2 dir = (uMousePos - uPreviousMousePos) * aspectVec; float dist = length(dir); if (dist > 0.0) { dir = dir / dist; } else { dir = vec2(1.0, 0.0); }float rad = 0.1800 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;float t = dist > 0.0 ? clamp(dot(correctedUv - uPreviousMousePos * aspectVec, dir) / dist, 0.0, 1.0) : 0.0; vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * aspectVec; float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.6100, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.0000 * 0.03) + 0.0000 * 0.015, 0.0000); vec3 lastFrameColor = texture(uPingPongTexture, sampleUv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); mouseColor = pow(mouseColor, vec3(2.2)); float intensity = min(0.7, dist * 10.0) * s * 0.4; vec3 draw = mix(lastFrameColor, mouseColor, intensity); draw *= pow(0.5000, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"pixelate","usesPingPong":false,"amount":0.61,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"45721073-5ac7-4e4d-aa43-150bf3eb9faa","animating":false,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"14574fff-95f0-4126-a732-1e680e73acc1","prop":"amount","transition":{"delay":2475,"duration":2180,"ease":"easeInOutQuart"},"complete":false,"progress":0,"value":0.78,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":1691,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x/uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float gridSize = (uAmount + 0.01) * 0.083; float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * mix(aspectRatio, 1./aspectRatio, 0.5); vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec2 relativePos = mod(offsetUv, cellSize) / cellSize - 0.5; float dist = length(relativePos); float x = mix(uv.x, pixelatedCoord.x, vec2(1, 1).x); float y = mix(uv.y, pixelatedCoord.y, vec2(1, 1).y); vec4 color = texture(uTexture, vec2(x, y)); float edgeSmoothing = 0.02; float alpha = 1.0 - smoothstep(1.0000 - edgeSmoothing, 1.0000, dist); if(1 == 1) { color.rgb = mix(vec3(0, 0, 0), color.rgb, alpha); } else { color.a *= alpha; }color *= color.a; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"texturize","usesPingPong":false,"glitch":0,"speed":0.71,"texture":false,"parentLayer":"30d271e1-27d8-4663-b222-fddec409cf4f","animating":false,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"e31abe7a-f7c0-4d31-8068-66c99cc66c3e","prop":"glitch","transition":{"ease":"easeInOutQuart","delay":3775,"duration":900},"complete":false,"progress":0,"value":0.83,"endValue":0,"initialized":false,"breakpoints":[],"loop":"forwards","loopDelay":5000,"uniformData":{"type":"1f","name":"uGlitch"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uGlitch; uniform float uTime;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5)); float timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5)); float sizeX = 0.1500 * 0.2 * timeRand1; float sizeY = 0.1500 * 0.2 * timeRand2; float floorY = floor(uv.y/sizeY) + 0.005; float floorX = floor(uv.x/sizeX) + 0.005; float phase = 0.0100 * 0.01; float chromab = 1.0000 * 0.75; float offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - 0.1500); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockRand = randFibo(blockUV); float blockTimeRand = timeRand1; float blockNoise = mix( 1., step(0.8, randFibo(vec2(blockTimeRand, blockRand))), 0.5900 );float offsetX = 0.8000 * 0.5 * blockNoise; float offsetY = 0.0900 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5)); float randX = randFibo(vec2(cos(floorX + offset + phase), 0.5)); float glitchModX = max(0.005, sign(randY - 0.5 - (1. - uGlitch*2.)/2.)); float glitchModY = max(0.005, sign(randX - 0.5 - (1. - uGlitch*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7)); float randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9)); float offX = (randOffX * offsetX - offsetX/2.)/5.; float offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0); offY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.0000; float timeOffset = uTime * 0.05; float sinY = sin((uv.y + 0.0100) * waveFreq * (1. - 0.1500) * 2. + timeOffset); float rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.0000; float sinWaveX = sin(uv.y * waveFreq + uTime); float sinWaveY = sin(uv.x * waveFreq + uTime); uv.x += sinWaveX * waveAmp + rogue; uv.y += sinWaveY * waveAmp; float waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995) ); vec2 blueOffset = vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995) );color.r = texture(uTexture, redOffset).r; color.b = texture(uTexture, blueOffset).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.6368286445012787,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":["78bb30ea-7db6-402b-99c8-a6f7228feceb","45721073-5ac7-4e4d-aa43-150bf3eb9faa","30d271e1-27d8-4663-b222-fddec409cf4f"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"6fb997b1-5f91-466c-bdab-9779e507618b","prop":"opacity","transition":{"ease":"easeInOutQuart","duration":350,"delay":2150},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uOpacity"}}],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":0.5820000000000001,"widthMode":"relative","height":0.5689050000000001,"heightMode":"auto","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"src":"/img/work/hbr.jpg","naturalWidth":1280,"naturalHeight":782,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform float uOpacity; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"image"}],"options":{"name":"hbr","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.33","id":"8d70tr6EMy2NnXHhshGi"}